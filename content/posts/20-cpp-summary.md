---
title: 'C++ 查漏补缺'
date: 2021-01-29
published: true
slug: 20-cpp-summary
tags: ['C++']
cover_image: "./images/p20.jpg"
canonical_url: false
description: '温故知新（C++）'
---

## 1. 静态类型

C++ 是静态类型的语言，类型检查发生在编译期，所以变量必须声明数据类型。与之相对应的是 Python，动态数据类型，直到程序运行时才能确定数据类型。

## 2. 带符号和不带符号的数据类型

切记不要混用带符号类型和不带符号类型。因为强制类型转换时和想象中的不一致，根源在于补码。也就是无符号类型采用的不是补码，和有符号类型采用补码表示。

> 例如 `unsigned a = -1` 转换为 int 后 `a = 4294967295` 。

## 3. 字符串和字符

字符串（string）实际上是由字符（char）组成，也就是一个字符数组。

## 4. 初始化和赋值的区别

初始化是在创建变量时赋予的初始值，而初始化是将对象的原始值擦除，采用新值来替代。

所以二者并不等价！

## 5. 声明（declaration）和定义（definition）的区别

定义分配了内存空间而声明没有！使用场景一般是多个文件中，一个文件要使用另外一个文件中已经定义好的变量，那么在该文件中则需要先声明！ 

> 声明采用关键字 extern 实现，例如：`extern int a`。 声明和定义不能同时使用，这是错误写法： `extern int a = 1` 。

## 6. 引用

可以将引用理解为别名，因为指向是同一块内存地址！所以后续的操作都体现到了同一个对象身上，区别就是名字不同。

## 7. 野指针和悬空指针

初始化所有指针！因为未经初始化的指针会被随机赋值，也就是野指针。如果随机赋值恰好指向了某个存值的地址那么就无法区分该值是否合法。

还有一种悬空指针，表示指针指向的内存空间被释放了，那么该指针就是非法内存访问了。

野指针和悬空指针都是指向无效的内存区域。

## 8. const

const 保证了变量中所存内容不能被改变。所以必须被初始化，因为随机赋值后续无法被修改也就没意义了。

## 9. 预处理指令



## 10. 引用

引用必须初始化，引用初始化后不能被改变。

> 但是为什么？最初我是无法理解的，但是理解本质后非常简单。其实引用本质上是一个 const 修饰的指针常量。`int& r = a;` 等价于 `int * const r = &a;` ，const 限定了 r 的值不能变化，所以以上两句话就显得很合理的。

## 11. 重载

函数的返回值不能作为重载的条件，因为会导致二义性。

函数重载的条件：

1. 同一作用域下。
2. 函数名相同。
3. 参数类型不同，参数个数不同，参数顺序不同。

除此之外函数在遇到默认参数时也可能会产生二义性。

## 12. 构造函数

编译器提供默认构造函数，析构函数，拷贝函数三种构造函数。

如果写了有参的构造函数那么编译器提供的默认构造函数就无法使用了！但是默认的拷贝构造函数依旧可以使用。

如果写了拷贝构造函数，C++ 对于其他构造函数均不提供。

## 13. 深拷贝和浅拷贝

深拷贝指在堆中重新申请内存空间，与之相对应的浅拷贝则指简单的赋值拷贝操作。

编译器的默认拷贝构造函数是浅拷贝实现，那么析构函数删除对象后可能会影响到另外一个函数。可以改成深拷贝，也就是重新 new 对象，在堆中重新开辟空间。

综上，如果存在堆中开辟空间的属性，那么需要将拷贝构造函数改成深拷贝。因为浅拷贝可能存在问题。

## 14. 初始化列表

之前没有学过这种写法，第一次遇到时有点懵，也不知道该如何搜索。没想到这么简单，就是一个初始化赋值而已。

下面两种写法等价！

```cpp
Person(int a,int b,int c) : m_A(a) , m_B(b) , m_C(c) {}

Person(int a,int b,int c) {
    m_A = a;
    m_B = b;
    m_C = c;
}
```

## 15. 对象构造顺序

场景：类 A 调用了类 B ，那么构造函数时的顺序是什么？析构的顺序是什么？

*当类中成员是其他类对象时，会先构造对象成员，再调用本类的构造函数。析构顺序反之。*

> 先构造类 B 再构造类 A 。析构是先 A 再 B！例如 A 是人，B 是手机，在初始化人时发现涉及到了手机，那么会先构造手机。也就是先构造其他对象再构造自身。

## 16. 静态 static

所有对象都共享同一个静态成员函数。

静态成员函数只能访问静态的成员变量。

静态变量不属于类对象，非静态成员函数也不属于类对象。

只有非静态成员变量属于类对象。

## 17. 常函数和常对象

在成员函数后加上 const 后表示该函数是一个常函数。

例如：`void a() const {}` 。等价于 `const int * a;` 表示指针指向地址中所存储的值不能被改变，而指针的指向是可以改变的。

如果非得修改某些变量的值，那么需要使用 mutable 。例如 `mutable int a;` 。

在对象前加上 const 可以将其设置为常对象（`const Person p`）。常对象不能修改属性值，但是如果属性是被 mutable 修饰的话是可以被修改的。

常对象只能调用常函数，因为调用普通成员函数会修改属性。所以本质上还是是否涉及到属性的修改上。

## 18. 继承

![image](https://cdn.jsdelivr.net/gh/weijiew/pic@master/images/image.4gt3wnu812g0.png)

继承的时候先构造父类再构造子类，析构反之，先析构子类再析构父类。

https://www.bilibili.com/video/BV1et411b73Z?p=132