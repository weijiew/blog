---
title: 'C++ 查漏补缺'
date: 2021-01-29
published: true
slug: 20-cpp-summary
tags: ['C++']
cover_image: "./images/p20.jpg"
canonical_url: false
description: '温故知新'
---
:::note
最近需要用到 C++ ，花了三天时间把[黑马的这套课](https://www.bilibili.com/video/BV1et411b73Z)看完了。
顺便把里面的项目敲了一遍，[repo](https://github.com/weijiew/cpp-study-cases)。

我能这么快看完一方面是因为 Java、Python 的基础，另一方面则是已经写过不少代码了，有种水到渠成的感觉。
当然 C++ 确实复杂，需要花时间去沉淀，再次加深了面向对象的理解。大一学的时候很多不明白的东西现在都能理解了。
另一方面也感叹如果大一直接看这个会省去多少精力啊，当然弯路也不可避免，有些坑踩过后才印象深刻。

最后的那两个项目不想做了，写下来估计得几千行，后续有时间再做吧。最近 C++ 学的有点过头，先缓缓。
:::
## 1. 静态类型

C++ 是静态类型的语言，类型检查发生在编译期，所以变量必须声明数据类型。与之相对应的是 Python，动态数据类型，直到程序运行时才能确定数据类型。

## 2. 带符号和不带符号的数据类型

切记不要混用带符号类型和不带符号类型。因为强制类型转换时和想象中的不一致，根源在于补码。也就是无符号类型采用的不是补码，和有符号类型采用补码表示。

> 例如 `unsigned a = -1` 转换为 int 后 `a = 4294967295` 。

## 3. 字符串和字符

字符串（string）实际上是由字符（char）组成，也就是一个字符数组。

## 4. 初始化和赋值的区别

初始化是在创建变量时赋予的初始值，而初始化是将对象的原始值擦除，采用新值来替代。

所以二者并不等价！

## 5. 声明（declaration）和定义（definition）的区别

定义分配了内存空间而声明没有！使用场景一般是多个文件中，一个文件要使用另外一个文件中已经定义好的变量，那么在该文件中则需要先声明！ 

> 声明采用关键字 extern 实现，例如：`extern int a`。 声明和定义不能同时使用，这是错误写法： `extern int a = 1` 。

## 6. 引用

可以将引用理解为别名，因为指向是同一块内存地址！所以后续的操作都体现到了同一个对象身上，区别就是名字不同。

## 7. 野指针和悬空指针

初始化所有指针！因为未经初始化的指针会被随机赋值，也就是野指针。如果随机赋值恰好指向了某个存值的地址那么就无法区分该值是否合法。

还有一种悬空指针，表示指针指向的内存空间被释放了，那么该指针就是非法内存访问了。

野指针和悬空指针都是指向无效的内存区域。

## 8. const

const 保证了变量中所存内容不能被改变。所以必须被初始化，因为随机赋值后续无法被修改也就没意义了。

## 9. 预处理指令



## 10. 引用

引用必须初始化，引用初始化后不能被改变。

> 但是为什么？最初我是无法理解的，但是理解本质后非常简单。其实引用本质上是一个 const 修饰的指针常量。`int& r = a;` 等价于 `int * const r = &a;` ，const 限定了 r 的值不能变化，所以以上两句话就显得很合理的。

## 11. 重载

函数的返回值不能作为重载的条件，因为会导致二义性。

函数重载的条件：

1. 同一作用域下。
2. 函数名相同。
3. 参数类型不同，参数个数不同，参数顺序不同。

除此之外函数在遇到默认参数时也可能会产生二义性。

## 12. 构造函数

编译器提供默认构造函数，析构函数，拷贝函数三种构造函数。

如果写了有参的构造函数那么编译器提供的默认构造函数就无法使用了！但是默认的拷贝构造函数依旧可以使用。

如果写了拷贝构造函数，C++ 对于其他构造函数均不提供。

## 13. 深拷贝和浅拷贝

深拷贝指在堆中重新申请内存空间，与之相对应的浅拷贝则指简单的赋值拷贝操作。

编译器的默认拷贝构造函数是浅拷贝实现，那么析构函数删除对象后可能会影响到另外一个函数。可以改成深拷贝，也就是重新 new 对象，在堆中重新开辟空间。

综上，如果存在堆中开辟空间的属性，那么需要将拷贝构造函数改成深拷贝。因为浅拷贝可能存在问题。

## 14. 初始化列表

之前没有学过这种写法，第一次遇到时有点懵，也不知道该如何搜索。没想到这么简单，就是一个初始化赋值而已。

下面两种写法等价！

```cpp
Person(int a,int b,int c) : m_A(a) , m_B(b) , m_C(c) {}

Person(int a,int b,int c) {
    m_A = a;
    m_B = b;
    m_C = c;
}
```

## 15. 对象构造顺序

场景：类 A 调用了类 B ，那么构造函数时的顺序是什么？析构的顺序是什么？

*当类中成员是其他类对象时，会先构造对象成员，再调用本类的构造函数。析构顺序反之。*

> 先构造类 B 再构造类 A 。析构是先 A 再 B！例如 A 是人，B 是手机，在初始化人时发现涉及到了手机，那么会先构造手机。也就是先构造其他对象再构造自身。

## 16. 静态 static

所有对象都共享同一个静态成员函数。

静态成员函数只能访问静态的成员变量。

静态变量不属于类对象，非静态成员函数也不属于类对象。

只有非静态成员变量属于类对象。

## 17. 常函数和常对象

在成员函数后加上 const 后表示该函数是一个常函数。

例如：`void a() const {}` 。等价于 `const int * a;` 表示指针指向地址中所存储的值不能被改变，而指针的指向是可以改变的。

如果非得修改某些变量的值，那么需要使用 mutable 。例如 `mutable int a;` 。

在对象前加上 const 可以将其设置为常对象（`const Person p`）。常对象不能修改属性值，但是如果属性是被 mutable 修饰的话是可以被修改的。

常对象只能调用常函数，因为调用普通成员函数会修改属性。所以本质上还是是否涉及到属性的修改上。

## 18. 继承

![image](https://cdn.jsdelivr.net/gh/weijiew/pic@master/images/image.4gt3wnu812g0.png)

继承的时候先构造父类再构造子类，析构反之，先析构子类再析构父类。

## 19. 多态

多态分为静态多态和动态多态，区别在于前者是编译器确定而后者是运行期确定。

虚函数表。

因为虚函数通常需要在子类中重写，没什么意义。因此可以将其改写为纯虚函数，写法：`virtual void func() = 0;`。

只要有一个纯虚函数那么该类就是抽象类。对于抽象类而言无法实例化对象，必须重写父类中的纯虚函数，否则也属于抽象类。
 
## 20. 指针占几个字节？

不管什么类型的指针均占 4 个字节。

指针表示地址，而计算机 64 位，32 位表示通用寄存器一次的寻址能力，也就是地址总线的宽度。因为一个字节等于 8 位，所以 64 位相当于 8 个字节。而 32 位相当于 4 个字节。但是编译器为了兼容 32 位和 64 位系统设定了指针都是 4 个字节。

综上，系统只是决定了指针所占字节数的上限，真正决定具体值的是编译器。

## 21. 抽象类中析构函数要改为虚析构函数

如果不改成虚析构函数，父类会直接调用改析构函数进而导致子类的析构函数没有调用导致内存泄漏。

加上虚析构函数后可以保证父类调用析构函数时作用到子类上。

纯虚函数只需要代码声明即可，而纯虚析构既需要代码声明也需要实现。

纯虚析构写好后该类就属于抽象类，而抽象类无法实例化对象。

虚析构和纯虚析构都是用来解决父类指针释放子类对象问题的。

如果子类中没有涉及到堆区数据，可以不写为虚析构和纯虚析构。

## 22. 模板

1. 如果函数模板和普通模板都可以实现，那么优先调用普通函数。
2. 可以通过调用空模板参数列表来强制调用函数模板。
3. 函数模板也可以发生重载。
4. 如果函数模板可以产生更好的匹配，优先调用函数模板。

为了避免二义性，当使用函数模板后就尽量不要使用普通函数。

模板也存在局限性，例如比较类是否相等，这个问题可以通过重载模板来解决。也就是具体化模板。

学模板不是为了使用，而是在 STL 中能够灵活运用系统所提供的模板。

在模板定义语法中关键字 class 与 typename 的作用完全一样。

除了函数之外，类也存在模板。

类模板和函数模板的区别：

1. 类模板没有自动类型推导。
2. 类模板的模板参数列表可以有默认参数。

类模板中的成员函数并不是一开始就创建，而是在调用的时候才创建。

说白了，模板还是为了尽可能的复用代码！

如果父类是类模板，那么子类继承父类时需要声明模板的数据类型。

如果存在多个文件，声明写在 .h 文件中，实现写在 .cpp 文件中时调用模板会导致编译失败。

因为编译器在扫描 .h 文件时不会去扫描 .cpp 文件，等于没有编译模板那一部分的代码。下面有两种解决方法：

1. 直接引入 .cpp 文件。
2. 将声明和实现写在一起，然后将 .h 文件改为 .hpp 文件。（推荐）

导致这个问题的本质原因还是类模板调用成员函数时是在调用阶段，导致链接不到文件。

## 23. STL

STL 存在六大组件：容器，算法，迭代器，仿函数，适配器（配接器），空间配置器。

容器分为序列容器和关联容器，前者强调元素之间的相对顺序。

https://www.bilibili.com/video/BV1et411b73Z?p=189